#include "AntimalwareService.h"



namespace Antimalware::ServiceApp
{
	int AntimalwareService::Init()
	{
		
		//malwareData.reset(new DataIO::RecordBank(std::filesystem::current_path().string()+"\\baseData.bin"));
		malwareData.reset(new DataIO::RecordBank("D:\\Visual\\C++\\ZI\\antyTry\\antyTry\\baseData.bin"));
		fw.reset(new FileWorker());
		scEn.reset(new Engen::ScanEngen(malwareData, fw));
		data.reset(new schrodingerData());		
		monit.reset(new Monitor(scEn, data));
		schedul.reset(new Schedule(scEn));
		return 0;
	}

	std::pair<HANDLE, HANDLE> AntimalwareService::waitConnection()
	{
		HANDLE pipe = CreateNamedPipe(
			L"\\\\.\\pipe\\AntimalwarePipe",
			PIPE_ACCESS_DUPLEX,
			PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
			PIPE_UNLIMITED_INSTANCES,
			4096, 4096, 5000, NULL);
		ConnectNamedPipe(pipe, NULL);
		HANDLE pipeBack = CreateNamedPipe(
			L"\\\\.\\pipe\\AntimalwarePipeBack",
			PIPE_ACCESS_DUPLEX,
			PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
			PIPE_UNLIMITED_INSTANCES,
			4096, 4096, 5000, NULL);
		ConnectNamedPipe(pipeBack, NULL);
		backList.push_back(pipeBack);
		return std::make_pair(pipe,pipeBack);
	}

	void AntimalwareService::work(std::pair<HANDLE, HANDLE> pipes)
	{
		Messanger pipeIO(pipes.first,1024);
		Messanger pipeIOBack(pipes.second, 1024);
		sendFirsrInfo(pipeIOBack);
		while (true)
		{
			auto res = pipeIO.getMSG();
			if (!res.has_value())
			{
				break;
			}
			std::thread th(&AntimalwareService::movment, this, res.value(),pipeIOBack);
			th.detach();
		}
		CloseHandle(pipes.first);
		CloseHandle(pipes.second);
	}

	void AntimalwareService::movment(return_type param, Messanger pipeIOBack)
	{
		switch (param.first)
		{
		case Command::START_SCAN:
		{
			bool isStop = true;
			auto objArray = Engen::scanGen(param.second.second);
			pipeIOBack.sendValue(Command::SCAN_COUNT, objArray.size());
			scEn->remuse();
			int counter = 0;
			for (auto& el : objArray)
			{
				if (isStop = scEn->isStop())
					break;
				std::string result = scEn->scan(el);
				if (!result.empty())
				{
					data->addDistruct(el.filePath);
					++counter;
				}
				pipeIOBack.sendCharArray(Command::START_SCAN, reportGen(std::move(el.filePath.string()), result));
			}
			if (!isStop)
				pipeIOBack.sendCharArray(Command::START_SCAN,
					"\r\nTotal scan is: " + std::to_string(objArray.size()) + "\r\nSafe file: " + std::to_string(objArray.size() - counter) + "\r\nDistrust: " + std::to_string(counter) + "\r\n");
			else
				pipeIOBack.sendCharArray(Command::START_SCAN, "Scan was stopped");
			scEn->remuse();
			return_type sendBack;
			sendBack.first = Command::UPDATE_DATA;
			movment(sendBack, pipeIOBack);
			break;
		}
		case Command::STOP_SCAN:
			scEn->stopScan();
			break;
		case Command::MOV_TO_QUAR:
			for (auto& el : param.second.first)
			{
				int callbackInfo = -1;
				if (fw->moveToQuar(data->getPathDistrust(el)))
					if (data->moveToQuaranList(el))
						callbackInfo = el;
				pipeIOBack.sendValue(Command::MOV_TO_QUAR, callbackInfo);
			}
			break;
		case Command::DELETE_FILE:
			for (auto& el : param.second.first)
			{
				int callbackInfo = -1;
				if (fw->removeFile(data->getPathDistrust(el)))
					if (data->itRemove(el))
						callbackInfo = el;
				pipeIOBack.sendValue(Command::DELETE_FILE, callbackInfo);
			}
			break;
		case Command::BACK_FROM_QUAR:
			for (auto& el : param.second.first)
			{
				int callbackInfo = -1;
				if (fw->recoverFile(data->getPathQuarantin(el)))
					if (data->restorFromQuarantine(el))
						callbackInfo = el;
				pipeIOBack.sendValue(Command::BACK_FROM_QUAR, callbackInfo);
			}
			break;
		case Command::ADD_MONIT:
			for (auto& el : param.second.second)
			{
				if (monit->addFile(el))
					pipeIOBack.sendCharArray(param.first, el);
			}
			break;
		case Command::REM_MONIT:
			for (auto& el : param.second.first)
				if (monit->removeFile(el))
					pipeIOBack.sendValue(param.first, el);
			break;
		case Command::SCHEDUL:
			if (param.second.second.size() == 1)
				if (param.second.second.front() == "$ServiceInfo$")
				{
					pipeIOBack.sendCharArray(param.first, schedul->getList());
					break;
				}
			schedul->clear();
			for (auto& el : param.second.second)
				schedul->addEl(el);
			pipeIOBack.sendCharArray(param.first, schedul->getList());
			break;
		case Command::UPDATE_DATA:
		{
			std::vector<std::string> vec;
			vec = std::move(data->getDist());
			vec.emplace_back("$ServiceInfo$");
			for (auto& el : data->getQuar())
				vec.emplace_back(el);
			pipeIOBack.sendCharArray(param.first, vec);
			break;
		}
		case Command::OFF_IT:
			this->data->saveData();
			this->monit->saveData();
			this->schedul->saveData();
			for (auto& el : backList)
				pipeIOBack.sendCharArray(Command::OFF_IT,"");
			ExitProcess(0);
			break;
		default:
			break;
		}
	}

	std::string AntimalwareService::reportGen(std::string path, std::string& isSafe)
	{
		return path += isSafe.empty() ? " is safe" : " found malware " + isSafe;
	}

	void AntimalwareService::monitorBackGround()
	{
		return_type backInfo;
		backInfo.first = Command::UPDATE_DATA;
		Messanger msg(INVALID_HANDLE_VALUE,1024);
		while (true)
		{
			if (monit->isFoundSmt())
				for (auto&el:backList)
					if (el != INVALID_HANDLE_VALUE)
					{
						msg.setPipe(el, 1024);
						movment(backInfo, msg);
					}
			std::this_thread::sleep_for(std::chrono::seconds(5));

		}
	}

	void AntimalwareService::scheduleBackGround()
	{
		return_type backInfo;
		Messanger msg(INVALID_HANDLE_VALUE, 1024);
		std::vector<std::string> vec;
		while (true)
		{
			vec = schedul->isFindSmt();
			if (vec.size())
			{
				for (auto& el : vec)
					data->addDistruct(el);
				for (auto& el : backList)
					if (el != INVALID_HANDLE_VALUE)
					{
						backInfo.first = Command::UPDATE_DATA;
						msg.setPipe(el, 1024);
						movment(backInfo, msg);
						backInfo.first = Command::SCHEDUL;
						backInfo.second.second.emplace_back("$ServiceInfo$");
						movment(backInfo, msg);
					}
			}
			std::this_thread::sleep_for(std::chrono::seconds(61));
		}
	}

	void AntimalwareService::sendFirsrInfo(Messanger& pipe)
	{
		return_type sendBack;
		sendBack.first = Command::UPDATE_DATA;
		movment(sendBack, pipe);
		sendBack.first = Command::SCHEDUL;
		pipe.sendCharArray(sendBack.first, schedul->getList());
		sendBack.first = Command::ADD_MONIT;
		pipe.sendCharArray(sendBack.first, monit->getList());
	}

	void AntimalwareService::DoWork()
	{
		auto con = waitConnection();
		std::thread th1(&AntimalwareService::work,this,con);
		th1.detach();
		std::this_thread::sleep_for(std::chrono::microseconds(100));
		if (onlyOnce)
		{
			onlyOnce = !onlyOnce;
			std::thread th2(&AntimalwareService::monitorBackGround, this);
			th2.detach();
			std::thread th3(&AntimalwareService::scheduleBackGround, this);
			th3.detach();
			std::thread th4(&Monitor::start, monit.get());
			th4.detach();
			std::thread th5(&Schedule::start, schedul.get());
			th5.detach();
		}
	}

	int AntimalwareService::DoStop()
	{
		this->data->saveData();
		this->monit->saveData();
		this->schedul->saveData();
		for (auto& el : backList)
		{
			FlushFileBuffers(el);
			DisconnectNamedPipe(el);
			CloseHandle(el);
		}
		return 0;
	}

	AntimalwareServiceFactory::AntimalwareServiceFactory()
	{
	}

	std::unique_ptr<ServiceLib::ServiceManagement::Service> AntimalwareServiceFactory::Create()
	{
		return std::make_unique<AntimalwareService>();
	}

}